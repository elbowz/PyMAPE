{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Distributed and decentralized MonitorAnalyzePlanExecute-Knowledge loops framework Framework to support the development and deployment of Autonomous (Self-Adaptive) Systems Source Code : https://github.com/elbowz/PyMAPE Documentation : https://elbowz.github.io/PyMAPE Requirements \u00b6 Python 3.8+ RxPY PyYAML AIOHTTP FastAPI Uvicorn Redis-purse Influxdb-client Key features \u00b6 CONTAINMENT Reuse, modularity and isolation of MAPE components as first-class entity . COMMUNICATION INTERFACE (STANDARDIZATION) Shared interface between components that allow stream communication, filtering, pre/post processing, data exchange communication and routing. DISTRIBUTION Multi-device distribution of MAPE loops and components. DECENTRALIZED PATTERNS Flat p2p and/or hierarchical architectures of loops and components with concerns separation. Allowing runtime pattern reconfiguration (stopping/starting, (un)linking, adding/removing). NETWORK COMMUNICATION PARADIGMS Different paradigms (blackboard, direct message) and protocols for various patterns interactions. STATE / KNOWLEDGE Distributed multi-scope (global, level, loop) Knowledge with partitioning and/or (full/partial async) replication. Paradigms and tools \u00b6 REACTIVE SYSTEM/PROGRAMMING AND STREAM System reactive to external event. Pillars: Responsive, Resilient, Elastic and Message Driven . Specific case of event-driven programming to avoid callback hell. REACTIVEX (OBSERVER PATTERN) Observables represent a source of events. An observer subscribes to an observable to receive items emitted (Hot, Cold, Subject,etc). Pipe operators modify streams flowing through them. ASYNCHRONOUS PROGRAMMING Manage (I/O bound) tasks concurrency with non-blocking I/O operations. REDIS, IN-MEMORY DATA STRUCTURE SERVER Distributed , in-memory key-value data structure (strings, hashes, lists, (ordered) sets, queue, lock) store, cache and message broker with keyspace notifications . Partitioning and/or (full/partial async) replication. Tip If you already know what is a Self-Adaptive system, a MAPE-K loop and related patterns: Getting Started","title":"Home"},{"location":"#requirements","text":"Python 3.8+ RxPY PyYAML AIOHTTP FastAPI Uvicorn Redis-purse Influxdb-client","title":"Requirements"},{"location":"#key-features","text":"CONTAINMENT Reuse, modularity and isolation of MAPE components as first-class entity . COMMUNICATION INTERFACE (STANDARDIZATION) Shared interface between components that allow stream communication, filtering, pre/post processing, data exchange communication and routing. DISTRIBUTION Multi-device distribution of MAPE loops and components. DECENTRALIZED PATTERNS Flat p2p and/or hierarchical architectures of loops and components with concerns separation. Allowing runtime pattern reconfiguration (stopping/starting, (un)linking, adding/removing). NETWORK COMMUNICATION PARADIGMS Different paradigms (blackboard, direct message) and protocols for various patterns interactions. STATE / KNOWLEDGE Distributed multi-scope (global, level, loop) Knowledge with partitioning and/or (full/partial async) replication.","title":"Key features"},{"location":"#paradigms-and-tools","text":"REACTIVE SYSTEM/PROGRAMMING AND STREAM System reactive to external event. Pillars: Responsive, Resilient, Elastic and Message Driven . Specific case of event-driven programming to avoid callback hell. REACTIVEX (OBSERVER PATTERN) Observables represent a source of events. An observer subscribes to an observable to receive items emitted (Hot, Cold, Subject,etc). Pipe operators modify streams flowing through them. ASYNCHRONOUS PROGRAMMING Manage (I/O bound) tasks concurrency with non-blocking I/O operations. REDIS, IN-MEMORY DATA STRUCTURE SERVER Distributed , in-memory key-value data structure (strings, hashes, lists, (ordered) sets, queue, lock) store, cache and message broker with keyspace notifications . Partitioning and/or (full/partial async) replication. Tip If you already know what is a Self-Adaptive system, a MAPE-K loop and related patterns: Getting Started","title":"Paradigms and tools"},{"location":"concepts/","text":"Self-Adaptive System \u00b6 A Self-Adaptive system (SAS) is able to automatically modify itself in response to changes in its operating environment 1 . The \"self\" prefix indicates that the systems decide autonomously (i.e. without or with minimal interference) how to adapt changes in their contexts. While some self-adaptive system may be able to function without any human intervention, guidance in the form of higher-level goals is useful and realized in many systems. MAPE-K loop \u00b6 A system could be made Self-Adaptive by adding sensors to monitor its runtime state, actuators to change it at runtime, and a separate reasoning mechanism to decide when it is appropriate to adapt the system, and how best to do so. This was famously referred to as the MAPE-K loop, or Monitor-Analyze-Plan-Execute using a shared base of Knowledge 2 . This architecture exposes explicitly the concept of feedback control loop and indentify the components and interfaces. Monitor Monitor the managed system and its context, filter the collected data and store relevant events in Knowledge. Analyze Explore the data, comparing it with known patterns, identifying any symptoms and saving them in the Knowledge as needed. Plan Interprets symptoms and devises a plan to achieve adaptation (or goal), usually according to guidelines and strategies. Execute Provides the control mechanisms to ensure the execution of the plan on the managed system. Knowledge Contains managed system information that can be shared among all MAPE components. It contains all the knowledge useful for the loop (eg. representation, policies to follow, metrics for evaluation, specific inference rules for each task, history, adaptation strategies, system topology, etc). Distributed and Decentralized \u00b6 When systems are large, complex, and heterogeneous, a single MAPE-K loop may not be sufficient for managing adaptation. In such cases, multiple MAPE-K loops may be employed that manage different parts of the system. In self-adaptive systems with multiple loops, the functions for monitoring, analyzing, planning, and effecting may be made by multiple components that coordinate with one another. That is, the functions may be decentralized throughout the multiple MAPE-K loops distributed on different nodes. 3 Different patterns of interacting control loops have been used in practice by centralizing and decentralizing the functions of self-adaption in different ways. Info Further and deeply information about different patterns related to decentralized and distributed system can be found in the paper \"On Patterns for Decentralized Control in Self-Adaptive Systems\", Danny Weyns In the next sections of documentations, we will see these patterns through the implementation of some ad-hoc examples. Discovering different approaches, trade-off, and of course the PyMAPE framework. \"A survey on engineering approaches for self-adaptive systems\" , C. Krupitzer, F. M. Roth, S. VanSyckel, G. Schiele, and C. Becker \u21a9 \"An architectural blueprint for autonomic computing\" , IBM White Paper, vol. 31, no. 2006 \u21a9 \"On Patterns for Decentralized Control in Self-Adaptive Systems\" , D. Weyns, B. Schmerl, V. Grassi, S. Malek, R. Mirandola, C. Prehofer, J. Wuttke, J. Andersson, H. Giese, and K. M. G\u00f6schka \u21a9","title":"Concepts and Terminology"},{"location":"concepts/#self-adaptive-system","text":"A Self-Adaptive system (SAS) is able to automatically modify itself in response to changes in its operating environment 1 . The \"self\" prefix indicates that the systems decide autonomously (i.e. without or with minimal interference) how to adapt changes in their contexts. While some self-adaptive system may be able to function without any human intervention, guidance in the form of higher-level goals is useful and realized in many systems.","title":"Self-Adaptive System"},{"location":"concepts/#mape-k-loop","text":"A system could be made Self-Adaptive by adding sensors to monitor its runtime state, actuators to change it at runtime, and a separate reasoning mechanism to decide when it is appropriate to adapt the system, and how best to do so. This was famously referred to as the MAPE-K loop, or Monitor-Analyze-Plan-Execute using a shared base of Knowledge 2 . This architecture exposes explicitly the concept of feedback control loop and indentify the components and interfaces. Monitor Monitor the managed system and its context, filter the collected data and store relevant events in Knowledge. Analyze Explore the data, comparing it with known patterns, identifying any symptoms and saving them in the Knowledge as needed. Plan Interprets symptoms and devises a plan to achieve adaptation (or goal), usually according to guidelines and strategies. Execute Provides the control mechanisms to ensure the execution of the plan on the managed system. Knowledge Contains managed system information that can be shared among all MAPE components. It contains all the knowledge useful for the loop (eg. representation, policies to follow, metrics for evaluation, specific inference rules for each task, history, adaptation strategies, system topology, etc).","title":"MAPE-K loop"},{"location":"concepts/#distributed-and-decentralized","text":"When systems are large, complex, and heterogeneous, a single MAPE-K loop may not be sufficient for managing adaptation. In such cases, multiple MAPE-K loops may be employed that manage different parts of the system. In self-adaptive systems with multiple loops, the functions for monitoring, analyzing, planning, and effecting may be made by multiple components that coordinate with one another. That is, the functions may be decentralized throughout the multiple MAPE-K loops distributed on different nodes. 3 Different patterns of interacting control loops have been used in practice by centralizing and decentralizing the functions of self-adaption in different ways. Info Further and deeply information about different patterns related to decentralized and distributed system can be found in the paper \"On Patterns for Decentralized Control in Self-Adaptive Systems\", Danny Weyns In the next sections of documentations, we will see these patterns through the implementation of some ad-hoc examples. Discovering different approaches, trade-off, and of course the PyMAPE framework. \"A survey on engineering approaches for self-adaptive systems\" , C. Krupitzer, F. M. Roth, S. VanSyckel, G. Schiele, and C. Becker \u21a9 \"An architectural blueprint for autonomic computing\" , IBM White Paper, vol. 31, no. 2006 \u21a9 \"On Patterns for Decentralized Control in Self-Adaptive Systems\" , D. Weyns, B. Schmerl, V. Grassi, S. Malek, R. Mirandola, C. Prehofer, J. Wuttke, J. Andersson, H. Giese, and K. M. G\u00f6schka \u21a9","title":"Distributed and Decentralized"},{"location":"typography/","text":"Decentralized Monitor Analyze Plan Execute Knowledge loops Software framework to support the development and deployment of Autonomous (Self-Adaptive) Systems Getting Started \u00b6 Install \u00b6 pip install pymape See Examples for play with some MAPE-K patterns. Install for Developers and Contributors \u00b6 git clone https://github.com/elbowz/PyMAPE.git cd PyMAPE poetry install note: you need to have already installed poetry Then use poetry shell and/or poetry run (eg. poetry run examples/coordinated-ambulance.py --speed 80 ) to exec your script inside the development environment. First loop (Ambulance) \u00b6 import mape from mape.loop import Loop \"\"\" MAPE Loop and elements definition \"\"\" loop = Loop ( uid = 'ambulance_emergency' ) @loop . monitor def detect ( item , on_next , self ): if 'speed_limit' in item : # Local volatile knowledge self . loop . k . speed_limit = item [ 'speed_limit' ] elif 'emergency_detect' in item : on_next ( item [ 'emergency_detect' ]) @loop . plan ( ops_in = ops . distinct_until_changed ()) async def policy ( emergency , on_next , self ): if emergency is True : self . last_speed_limit = self . loop . k . speed_limit new_speed = max ( self . last_speed_limit , self . emergency_speed ) on_next ({ 'speed' : new_speed }) on_next ({ 'siren' : True }) else : on_next ({ 'speed' : self . last_speed_limit }) on_next ({ 'siren' : False }) policy . emergency_speed = 160 @loop . execute def exec ( item : dict , on_next ): if 'speed' in item : ambulance . speed_limit = item [ 'speed' ] if 'siren' in item : ambulance . siren = item [ 'siren' ] for element in loop : element . debug ( Element . Debug . IN ) \"\"\" MAPE Elements connection \"\"\" detect . subscribe ( policy ) policy . subscribe ( exec ) # (1) # Starting monitor... detect . start () I'm a code annotation! I can contain code , formatted text , images, ... basically anything that can be written in Markdown. The range () function is used to generate a sequence of numbers. The HTML specification is maintained by the W3C . Hover me Traversing \u00b6 # Iterate over loops and element for loop in mape . app : logger . debug ( f \"* { loop . uid } \" ) for element in loop : logger . debug ( f \" - { element . uid } \" ) # Get all Execute elements [ element for element in loop_obj if isinstance ( element , Execute )] # Different access way to loop/element through dot-notation (path) mape . app . loop_uid . element_uid mape . app [ 'loop_uid.element_uid' ] 8.0.0 \u00b7 Feature flag Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. (1) Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa (2). I'm an annotation! I'm an annotation as well! If you already know what is a Self-Adaptive system and a MAPE-K loop: Getting Started Tab 1 Tab 2 # Iterate over loops and element for loop in mape . app : logger . debug ( f \"* { loop . uid } \" ) for element in loop : logger . debug ( f \" - { element . uid } \" ) # Get all Execute elements [ element for element in loop_obj if isinstance ( element , Execute )] # Different access way to loop/element through dot-notation (path) mape . app . loop_uid . element_uid mape . app [ 'loop_uid.element_uid' ] Phasellus posuere in sem ut cursus (1) casazzo \u00b6 $ pip install pymape ---> 100% Come fa # >>> $ ecco un custom prompt // sadasd $ a me si dai sdsd Docs \u00b6 Slides \u00b6 Introduction to PyMAPE with examples Examples \u00b6 Implementation of the 5 decentralized (and distributed) MAPE patterns described in the paper: \"On Patterns for Decentralized Control in Self-Adaptive Systems\", Danny Weyns Ambulance-Car Emergency (Information Sharing and Coordinated Control) Average Speed Enforcement (Master/Slave) Dynamic Carriageway (Regional Planning) Cruise Control with Distance Hold (Hierarchical Control) If you want try some examples (path examples/ ), refer to section # CLI EXAMPLES inside the source code of each one. The examples need furthers requirements, please see pyproject.toml or use poetry to install them . You also need a Redis and InfluxDB instance running, for example: docker run --name mape-redis -p 6379 :6379 \\ -v $( pwd ) /docker/redis:/usr/local/etc/redis \\ --rm redis redis-server /usr/local/etc/redis/redis.conf docker run --name mape-influxdb -p 8086 :8086 \\ -v $( pwd ) /docker/influxdb/data:/var/lib/influxdb2 \\ -v $( pwd ) /docker/influxdb/conf:/etc/influxdb2 \\ -e DOCKER_INFLUXDB_INIT_MODE = setup \\ -e DOCKER_INFLUXDB_INIT_USERNAME = user \\ -e DOCKER_INFLUXDB_INIT_PASSWORD = qwerty123456 \\ -e DOCKER_INFLUXDB_INIT_ORG = univaq \\ -e DOCKER_INFLUXDB_INIT_BUCKET = mape \\ -e DOCKER_INFLUXDB_INIT_RETENTION = 1w \\ -e DOCKER_INFLUXDB_INIT_ADMIN_TOKEN = <GENERATE_OR_TAKE_FROM_CONFIG_YAML> \\ --rm influxdb:2.0 See source for more information.","title":"Typography"},{"location":"typography/#getting-started","text":"","title":"Getting Started"},{"location":"typography/#install","text":"pip install pymape See Examples for play with some MAPE-K patterns.","title":"Install"},{"location":"typography/#install-for-developers-and-contributors","text":"git clone https://github.com/elbowz/PyMAPE.git cd PyMAPE poetry install note: you need to have already installed poetry Then use poetry shell and/or poetry run (eg. poetry run examples/coordinated-ambulance.py --speed 80 ) to exec your script inside the development environment.","title":"Install for Developers and Contributors"},{"location":"typography/#first-loop-ambulance","text":"import mape from mape.loop import Loop \"\"\" MAPE Loop and elements definition \"\"\" loop = Loop ( uid = 'ambulance_emergency' ) @loop . monitor def detect ( item , on_next , self ): if 'speed_limit' in item : # Local volatile knowledge self . loop . k . speed_limit = item [ 'speed_limit' ] elif 'emergency_detect' in item : on_next ( item [ 'emergency_detect' ]) @loop . plan ( ops_in = ops . distinct_until_changed ()) async def policy ( emergency , on_next , self ): if emergency is True : self . last_speed_limit = self . loop . k . speed_limit new_speed = max ( self . last_speed_limit , self . emergency_speed ) on_next ({ 'speed' : new_speed }) on_next ({ 'siren' : True }) else : on_next ({ 'speed' : self . last_speed_limit }) on_next ({ 'siren' : False }) policy . emergency_speed = 160 @loop . execute def exec ( item : dict , on_next ): if 'speed' in item : ambulance . speed_limit = item [ 'speed' ] if 'siren' in item : ambulance . siren = item [ 'siren' ] for element in loop : element . debug ( Element . Debug . IN ) \"\"\" MAPE Elements connection \"\"\" detect . subscribe ( policy ) policy . subscribe ( exec ) # (1) # Starting monitor... detect . start () I'm a code annotation! I can contain code , formatted text , images, ... basically anything that can be written in Markdown. The range () function is used to generate a sequence of numbers. The HTML specification is maintained by the W3C . Hover me","title":"First loop (Ambulance)"},{"location":"typography/#traversing","text":"# Iterate over loops and element for loop in mape . app : logger . debug ( f \"* { loop . uid } \" ) for element in loop : logger . debug ( f \" - { element . uid } \" ) # Get all Execute elements [ element for element in loop_obj if isinstance ( element , Execute )] # Different access way to loop/element through dot-notation (path) mape . app . loop_uid . element_uid mape . app [ 'loop_uid.element_uid' ] 8.0.0 \u00b7 Feature flag Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. (1) Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa (2). I'm an annotation! I'm an annotation as well! If you already know what is a Self-Adaptive system and a MAPE-K loop: Getting Started Tab 1 Tab 2 # Iterate over loops and element for loop in mape . app : logger . debug ( f \"* { loop . uid } \" ) for element in loop : logger . debug ( f \" - { element . uid } \" ) # Get all Execute elements [ element for element in loop_obj if isinstance ( element , Execute )] # Different access way to loop/element through dot-notation (path) mape . app . loop_uid . element_uid mape . app [ 'loop_uid.element_uid' ] Phasellus posuere in sem ut cursus (1)","title":"Traversing"},{"location":"typography/#casazzo","text":"$ pip install pymape ---> 100% Come fa # >>> $ ecco un custom prompt // sadasd $ a me si dai sdsd","title":"casazzo"},{"location":"typography/#docs","text":"","title":"Docs"},{"location":"typography/#slides","text":"Introduction to PyMAPE with examples","title":"Slides"},{"location":"typography/#examples","text":"Implementation of the 5 decentralized (and distributed) MAPE patterns described in the paper: \"On Patterns for Decentralized Control in Self-Adaptive Systems\", Danny Weyns Ambulance-Car Emergency (Information Sharing and Coordinated Control) Average Speed Enforcement (Master/Slave) Dynamic Carriageway (Regional Planning) Cruise Control with Distance Hold (Hierarchical Control) If you want try some examples (path examples/ ), refer to section # CLI EXAMPLES inside the source code of each one. The examples need furthers requirements, please see pyproject.toml or use poetry to install them . You also need a Redis and InfluxDB instance running, for example: docker run --name mape-redis -p 6379 :6379 \\ -v $( pwd ) /docker/redis:/usr/local/etc/redis \\ --rm redis redis-server /usr/local/etc/redis/redis.conf docker run --name mape-influxdb -p 8086 :8086 \\ -v $( pwd ) /docker/influxdb/data:/var/lib/influxdb2 \\ -v $( pwd ) /docker/influxdb/conf:/etc/influxdb2 \\ -e DOCKER_INFLUXDB_INIT_MODE = setup \\ -e DOCKER_INFLUXDB_INIT_USERNAME = user \\ -e DOCKER_INFLUXDB_INIT_PASSWORD = qwerty123456 \\ -e DOCKER_INFLUXDB_INIT_ORG = univaq \\ -e DOCKER_INFLUXDB_INIT_BUCKET = mape \\ -e DOCKER_INFLUXDB_INIT_RETENTION = 1w \\ -e DOCKER_INFLUXDB_INIT_ADMIN_TOKEN = <GENERATE_OR_TAKE_FROM_CONFIG_YAML> \\ --rm influxdb:2.0 See source for more information.","title":"Examples"},{"location":"getting-started/","text":"PyMAPE can be simply installed using pip, directly in your system or in a separated virtual environment to keep clean your main system. System Virtualenv $ pip install pymape ---> 100% $ python -m venv venv $ source venv/bin/activate # ( venv ) $ pip install pymape ---> 100% Examples dependencies If you intend play with the provided examples of different MAPE-K patterns, you should also install the dependency pip install -r examples/requirements.txt . Anyway before play with them, we need to run some docker containers. We will see them soon. Installation for Developers and Contributors \u00b6 If you want to contribute to the project, you have use poetry and follow the steps below: $ git clone https://github.com/elbowz/PyMAPE.git $ cd PyMAPE $ poetry install ---> 100% Then use poetry shell and/or poetry run (eg. poetry run examples/coordinated-ambulance.py --speed 80 ) to exec a script inside the development environment. Poetry and examples dependencies Using poetry you won't have to install the python packages dependencies needed to execute the examples .","title":"Installation"},{"location":"getting-started/#installation-for-developers-and-contributors","text":"If you want to contribute to the project, you have use poetry and follow the steps below: $ git clone https://github.com/elbowz/PyMAPE.git $ cd PyMAPE $ poetry install ---> 100% Then use poetry shell and/or poetry run (eg. poetry run examples/coordinated-ambulance.py --speed 80 ) to exec a script inside the development environment. Poetry and examples dependencies Using poetry you won't have to install the python packages dependencies needed to execute the examples .","title":"Installation for Developers and Contributors"},{"location":"getting-started/first-loop/","text":"First loop \u00b6 Let's write your first MAPE loop. You'll write a simplified loop of an ambulance that switch on/off the siren and increase speed in case of an emergency detected. import mape mape . init () # (1) # Our ambulance loop definition, named \"ambulance\" loop = mape . Loop ( uid = 'ambulance' ) # (2) # Monitor element of ambulance loop @loop . monitor # (3) def detect ( emergency , on_next ): # (4) on_next ( emergency ) mape . init () accept different params to setup pymape , allowing configuration by a config file and/or directly in the source code. uid is an unique identification for the defined loop. If you don't pass an uid , system provide a random one for you. Decorator create and register the new element monitor to the ambulance loop . The function name detect is used as uid of our element inside the ambulance loop. So, we have a loop ( ambulance ) made up of a single monitor element called detect . Loop and Element uid Loop uid ambulance must be unique in the whole app, instead detect (monitor uid) must be so only within the loop to which it belongs. This allow to address an element by its path (eg. ambulance.detect ). detect () function is the monitor element. It accepts at least two params: stream item ( emergency ) - the value in input of an element. The elements talk with each other by streams as ReactiveX philosophy. on_next - is the function to call with the value to pass to the next linked elements ( subscribed () ). It can be called 0 or N times, you haven't to confused with the function return . Go ahead with a plan for add policies in case of an emergency detected. @loop . plan ( uid = 'custom_policy' ) # (1) def policy ( emergency , on_next , self ): # Emergency plans if emergency is True : on_next ({ 'speed' : self . emergency_speed }) # (2) on_next ({ 'siren' : True }) else : on_next ({ 'speed' : 80 }) on_next ({ 'siren' : False }) policy . emergency_speed = 180 Differently from the monitor, here we choose the element uid ( custom_policy instead of policy ). Use the object property emergency_speed set externally. In this case, policy () has a third param self . When you add it to the function signature, you can directly access to the Element object behind the scene. This time, respect previous detect () , you pass a dict to the next linked element. The last element defined and registered is the execute element, exec applies the plan on the managed system (ie. ambulance), in our case simply print an output. @loop . execute def exec ( item , on_next ): if 'speed' in item : print ( f \"Speed: { item [ 'speed' ] } Km/h\" ) if 'siren' in item : print ( f \"Siren is { 'ON' if item [ 'siren' ] else 'OFF' } \" ) The last step to complete ambulance loop is to connect ( subscribe() ) the three elements: Subscribe Pipe detect . subscribe ( policy ) policy . subscribe ( exec ) from mape import operators as ops # (1) # Alternative way detect . pipe ( ops . through ( policy ), ops . through ( exec ) ) . subscribe () ops are all the RxPY operators plus some more extras. You are finally ready to try your ambulance emergency system, sending a detected emergency to the monitor element detect : detect ( True ) # (1) Just call the detect () function and pass the item as param. As you can see, nothing happens ! This is the wanted behaviour, because you have to start element detect whenever you are ready to receive the stream. Different elements behaviour Elements can have 3 different behaviours respect to the stream passing through them: manual start ( monitor ): the element cannot send or receive items until the .start() method invocation. This is often related to internal resource lifetime (eg. DB connection, socket, ...). This allow to connect all loops and elements before start receiving the stream. start on subscribe ( analyzer, planner ): the element will be started when someone is interested to it (ie. subscribed() ). start on init ( executer ): the element is ready from its initialization. So, we start del monitor element and simulate an emergency: detect . start () detect ( True ) Get the results: Speed: 180 Siren is ON Again, ending the emergency (ie. False ): detect ( False ) Get the results: Speed: 80 Siren is OFF Operators \u00b6 Inspired by the functional programming, there are plenty operators available in RxPY, they can be chained in a pipeline, allowing transformations, combinations, filtering, grouping, error managing, applying conditions, making math operations, and so on . There are more than 140 operators (about 400 variants), and we advise and encourage the creation of your custom operators following your need. Traversing \u00b6 # Iterate over loops and element for loop in mape . app : logger . debug ( f \"* { loop . uid } \" ) for element in loop : logger . debug ( f \" - { element . uid } \" ) # Get all Execute elements [ element for element in loop_obj if isinstance ( element , Execute )] # Different access way to loop/element through dot-notation (path) mape . app . loop_uid . element_uid mape . app [ 'loop_uid.element_uid' ]","title":"First loop"},{"location":"getting-started/first-loop/#first-loop","text":"Let's write your first MAPE loop. You'll write a simplified loop of an ambulance that switch on/off the siren and increase speed in case of an emergency detected. import mape mape . init () # (1) # Our ambulance loop definition, named \"ambulance\" loop = mape . Loop ( uid = 'ambulance' ) # (2) # Monitor element of ambulance loop @loop . monitor # (3) def detect ( emergency , on_next ): # (4) on_next ( emergency ) mape . init () accept different params to setup pymape , allowing configuration by a config file and/or directly in the source code. uid is an unique identification for the defined loop. If you don't pass an uid , system provide a random one for you. Decorator create and register the new element monitor to the ambulance loop . The function name detect is used as uid of our element inside the ambulance loop. So, we have a loop ( ambulance ) made up of a single monitor element called detect . Loop and Element uid Loop uid ambulance must be unique in the whole app, instead detect (monitor uid) must be so only within the loop to which it belongs. This allow to address an element by its path (eg. ambulance.detect ). detect () function is the monitor element. It accepts at least two params: stream item ( emergency ) - the value in input of an element. The elements talk with each other by streams as ReactiveX philosophy. on_next - is the function to call with the value to pass to the next linked elements ( subscribed () ). It can be called 0 or N times, you haven't to confused with the function return . Go ahead with a plan for add policies in case of an emergency detected. @loop . plan ( uid = 'custom_policy' ) # (1) def policy ( emergency , on_next , self ): # Emergency plans if emergency is True : on_next ({ 'speed' : self . emergency_speed }) # (2) on_next ({ 'siren' : True }) else : on_next ({ 'speed' : 80 }) on_next ({ 'siren' : False }) policy . emergency_speed = 180 Differently from the monitor, here we choose the element uid ( custom_policy instead of policy ). Use the object property emergency_speed set externally. In this case, policy () has a third param self . When you add it to the function signature, you can directly access to the Element object behind the scene. This time, respect previous detect () , you pass a dict to the next linked element. The last element defined and registered is the execute element, exec applies the plan on the managed system (ie. ambulance), in our case simply print an output. @loop . execute def exec ( item , on_next ): if 'speed' in item : print ( f \"Speed: { item [ 'speed' ] } Km/h\" ) if 'siren' in item : print ( f \"Siren is { 'ON' if item [ 'siren' ] else 'OFF' } \" ) The last step to complete ambulance loop is to connect ( subscribe() ) the three elements: Subscribe Pipe detect . subscribe ( policy ) policy . subscribe ( exec ) from mape import operators as ops # (1) # Alternative way detect . pipe ( ops . through ( policy ), ops . through ( exec ) ) . subscribe () ops are all the RxPY operators plus some more extras. You are finally ready to try your ambulance emergency system, sending a detected emergency to the monitor element detect : detect ( True ) # (1) Just call the detect () function and pass the item as param. As you can see, nothing happens ! This is the wanted behaviour, because you have to start element detect whenever you are ready to receive the stream. Different elements behaviour Elements can have 3 different behaviours respect to the stream passing through them: manual start ( monitor ): the element cannot send or receive items until the .start() method invocation. This is often related to internal resource lifetime (eg. DB connection, socket, ...). This allow to connect all loops and elements before start receiving the stream. start on subscribe ( analyzer, planner ): the element will be started when someone is interested to it (ie. subscribed() ). start on init ( executer ): the element is ready from its initialization. So, we start del monitor element and simulate an emergency: detect . start () detect ( True ) Get the results: Speed: 180 Siren is ON Again, ending the emergency (ie. False ): detect ( False ) Get the results: Speed: 80 Siren is OFF","title":"First loop"},{"location":"getting-started/first-loop/#operators","text":"Inspired by the functional programming, there are plenty operators available in RxPY, they can be chained in a pipeline, allowing transformations, combinations, filtering, grouping, error managing, applying conditions, making math operations, and so on . There are more than 140 operators (about 400 variants), and we advise and encourage the creation of your custom operators following your need.","title":"Operators"},{"location":"getting-started/first-loop/#traversing","text":"# Iterate over loops and element for loop in mape . app : logger . debug ( f \"* { loop . uid } \" ) for element in loop : logger . debug ( f \" - { element . uid } \" ) # Get all Execute elements [ element for element in loop_obj if isinstance ( element , Execute )] # Different access way to loop/element through dot-notation (path) mape . app . loop_uid . element_uid mape . app [ 'loop_uid.element_uid' ]","title":"Traversing"}]}