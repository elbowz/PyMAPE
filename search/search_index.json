{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Distributed and decentralized MonitorAnalyzePlanExecute-Knowledge loops framework Framework to support the development and deployment of Autonomous (Self-Adaptive) Systems Source Code : https://github.com/elbowz/PyMAPE Documentation : https://elbowz.github.io/PyMAPE - WIP Requirements \u00b6 Python 3.8+ RxPY PyYAML AIOHTTP FastAPI Uvicorn Redis-purse Influxdb-client Key features \u00b6 CONTAINMENT Reuse, modularity and isolation of MAPE components as first-class entity . COMMUNICATION INTERFACE (STANDARDIZATION) Shared interface between components that allow stream communication, filtering, pre/post processing, data exchange communication and routing. DISTRIBUTION Multi-device distribution of MAPE loops and components. DECENTRALIZED PATTERNS Flat p2p and/or hierarchical architectures of loops and components with concerns separation. Allowing runtime pattern reconfiguration (stopping/starting, (un)linking, adding/removing). NETWORK COMMUNICATION PARADIGMS Different paradigms (blackboard, direct message) and protocols for various patterns interactions. STATE / KNOWLEDGE Distributed multi-scope (global, level, loop) Knowledge with partitioning and/or (full/partial async) replication. Paradigms and tools \u00b6 REACTIVE SYSTEM/PROGRAMMING AND STREAM System reactive to external event. Pillars: Responsive, Resilient, Elastic and Message Driven . Specific case of event-driven programming to avoid callback hell. REACTIVEX (OBSERVER PATTERN) Observables represent a source of events. An observer subscribes to an observable to receive items emitted (Hot, Cold, Subject,etc). Pipe operators modify streams flowing through them. ASYNCHRONOUS PROGRAMMING Manage (I/O bound) tasks concurrency with non-blocking I/O operations. REDIS, IN-MEMORY DATA STRUCTURE SERVER Distributed , in-memory key-value data structure (strings, hashes, lists, (ordered) sets, queue, lock) store, cache and message broker with keyspace notifications . Partitioning and/or (full/partial async) replication. Tip If you already know what is a Self-Adaptive system, a MAPE-K loop and related patterns, jump to: Installation","title":"Home"},{"location":"#requirements","text":"Python 3.8+ RxPY PyYAML AIOHTTP FastAPI Uvicorn Redis-purse Influxdb-client","title":"Requirements"},{"location":"#key-features","text":"CONTAINMENT Reuse, modularity and isolation of MAPE components as first-class entity . COMMUNICATION INTERFACE (STANDARDIZATION) Shared interface between components that allow stream communication, filtering, pre/post processing, data exchange communication and routing. DISTRIBUTION Multi-device distribution of MAPE loops and components. DECENTRALIZED PATTERNS Flat p2p and/or hierarchical architectures of loops and components with concerns separation. Allowing runtime pattern reconfiguration (stopping/starting, (un)linking, adding/removing). NETWORK COMMUNICATION PARADIGMS Different paradigms (blackboard, direct message) and protocols for various patterns interactions. STATE / KNOWLEDGE Distributed multi-scope (global, level, loop) Knowledge with partitioning and/or (full/partial async) replication.","title":"Key features"},{"location":"#paradigms-and-tools","text":"REACTIVE SYSTEM/PROGRAMMING AND STREAM System reactive to external event. Pillars: Responsive, Resilient, Elastic and Message Driven . Specific case of event-driven programming to avoid callback hell. REACTIVEX (OBSERVER PATTERN) Observables represent a source of events. An observer subscribes to an observable to receive items emitted (Hot, Cold, Subject,etc). Pipe operators modify streams flowing through them. ASYNCHRONOUS PROGRAMMING Manage (I/O bound) tasks concurrency with non-blocking I/O operations. REDIS, IN-MEMORY DATA STRUCTURE SERVER Distributed , in-memory key-value data structure (strings, hashes, lists, (ordered) sets, queue, lock) store, cache and message broker with keyspace notifications . Partitioning and/or (full/partial async) replication. Tip If you already know what is a Self-Adaptive system, a MAPE-K loop and related patterns, jump to: Installation","title":"Paradigms and tools"},{"location":"append/","text":"","title":"Append"},{"location":"concepts/","text":"Self-Adaptive System \u00b6 A Self-Adaptive system (SAS) is able to automatically modify itself in response to changes in its operating environment 1 . The \"self\" prefix indicates that the systems decide autonomously (i.e. without or with minimal interference) how to adapt changes in their contexts. While some self-adaptive system may be able to function without any human intervention, guidance in the form of higher-level goals is useful and realized in many systems. MAPE-K loop \u00b6 A system could be made Self-Adaptive by adding sensors to monitor its runtime state, actuators to change it at runtime, and a separate reasoning mechanism to decide when it is appropriate to adapt the system, and how best to do so. This was famously referred to as the MAPE-K loop, or Monitor-Analyze-Plan-Execute using a shared base of Knowledge 2 . This architecture exposes explicitly the concept of feedback control loop and indentify the components and interfaces. Monitor Monitor the managed system and its context, filter the collected data and store relevant events in Knowledge. Analyze Explore the data, comparing it with known patterns, identifying any symptoms and saving them in the Knowledge as needed. Plan Interprets symptoms and devises a plan to achieve adaptation (or goal), usually according to guidelines and strategies. Execute Provides the control mechanisms to ensure the execution of the plan on the managed system. Knowledge Contains managed system information that can be shared among all MAPE components. It contains all the knowledge useful for the loop (eg. representation, policies to follow, metrics for evaluation, specific inference rules for each task, history, adaptation strategies, system topology, etc). Distributed and Decentralized \u00b6 When systems are large, complex, and heterogeneous, a single MAPE-K loop may not be sufficient for managing adaptation. In such cases, multiple MAPE-K loops may be employed that manage different parts of the system. In self-adaptive systems with multiple loops, the functions for monitoring, analyzing, planning, and effecting may be made by multiple components that coordinate with one another. That is, the functions may be decentralized throughout the multiple MAPE-K loops distributed on different nodes. 3 Different patterns of interacting control loops have been used in practice by centralizing and decentralizing the functions of self-adaption in different ways. Info Further and deeply information about different patterns related to decentralized and distributed system can be found in the paper \"On Patterns for Decentralized Control in Self-Adaptive Systems\", Danny Weyns In the next sections of documentations, we will see these patterns through the implementation of some ad-hoc examples. Discovering different approaches, trade-off, and of course the PyMAPE framework. \"A survey on engineering approaches for self-adaptive systems\" , C. Krupitzer, F. M. Roth, S. VanSyckel, G. Schiele, and C. Becker \u21a9 \"An architectural blueprint for autonomic computing\" , IBM White Paper, vol. 31, no. 2006 \u21a9 \"On Patterns for Decentralized Control in Self-Adaptive Systems\" , D. Weyns, B. Schmerl, V. Grassi, S. Malek, R. Mirandola, C. Prehofer, J. Wuttke, J. Andersson, H. Giese, and K. M. G\u00f6schka \u21a9","title":"Concepts and Terminology"},{"location":"concepts/#self-adaptive-system","text":"A Self-Adaptive system (SAS) is able to automatically modify itself in response to changes in its operating environment 1 . The \"self\" prefix indicates that the systems decide autonomously (i.e. without or with minimal interference) how to adapt changes in their contexts. While some self-adaptive system may be able to function without any human intervention, guidance in the form of higher-level goals is useful and realized in many systems.","title":"Self-Adaptive System"},{"location":"concepts/#mape-k-loop","text":"A system could be made Self-Adaptive by adding sensors to monitor its runtime state, actuators to change it at runtime, and a separate reasoning mechanism to decide when it is appropriate to adapt the system, and how best to do so. This was famously referred to as the MAPE-K loop, or Monitor-Analyze-Plan-Execute using a shared base of Knowledge 2 . This architecture exposes explicitly the concept of feedback control loop and indentify the components and interfaces. Monitor Monitor the managed system and its context, filter the collected data and store relevant events in Knowledge. Analyze Explore the data, comparing it with known patterns, identifying any symptoms and saving them in the Knowledge as needed. Plan Interprets symptoms and devises a plan to achieve adaptation (or goal), usually according to guidelines and strategies. Execute Provides the control mechanisms to ensure the execution of the plan on the managed system. Knowledge Contains managed system information that can be shared among all MAPE components. It contains all the knowledge useful for the loop (eg. representation, policies to follow, metrics for evaluation, specific inference rules for each task, history, adaptation strategies, system topology, etc).","title":"MAPE-K loop"},{"location":"concepts/#distributed-and-decentralized","text":"When systems are large, complex, and heterogeneous, a single MAPE-K loop may not be sufficient for managing adaptation. In such cases, multiple MAPE-K loops may be employed that manage different parts of the system. In self-adaptive systems with multiple loops, the functions for monitoring, analyzing, planning, and effecting may be made by multiple components that coordinate with one another. That is, the functions may be decentralized throughout the multiple MAPE-K loops distributed on different nodes. 3 Different patterns of interacting control loops have been used in practice by centralizing and decentralizing the functions of self-adaption in different ways. Info Further and deeply information about different patterns related to decentralized and distributed system can be found in the paper \"On Patterns for Decentralized Control in Self-Adaptive Systems\", Danny Weyns In the next sections of documentations, we will see these patterns through the implementation of some ad-hoc examples. Discovering different approaches, trade-off, and of course the PyMAPE framework. \"A survey on engineering approaches for self-adaptive systems\" , C. Krupitzer, F. M. Roth, S. VanSyckel, G. Schiele, and C. Becker \u21a9 \"An architectural blueprint for autonomic computing\" , IBM White Paper, vol. 31, no. 2006 \u21a9 \"On Patterns for Decentralized Control in Self-Adaptive Systems\" , D. Weyns, B. Schmerl, V. Grassi, S. Malek, R. Mirandola, C. Prehofer, J. Wuttke, J. Andersson, H. Giese, and K. M. G\u00f6schka \u21a9","title":"Distributed and Decentralized"},{"location":"first-loop/","text":"Let's write your first MAPE loop. You'll write a simplified loop of an ambulance that switch on/off the siren and increase speed in case of an emergency detected. Ambulance loop \u00b6 You'll implement this simple ambulance loop, composed of 3 connected elements: Monitor detect Planner custom_policy Executer exec In the next sections this graphical notation will be more clear. import mape mape . init () # (1) # Ambulance loop definition, named \"ambulance\" loop = mape . Loop ( uid = 'ambulance' ) # (2) # Monitor element of ambulance loop @loop . monitor # (3) def detect ( emergency , on_next ): # (4) on_next ( emergency ) mape . init () accept different params to setup PyMAPE, allowing configuration by a config file and/or directly in the source code. uid is an unique identification for the defined loop. If you don't pass an uid , system provide a random one for you. Decorator create and register the new element monitor to the ambulance loop . The function name detect is used as uid of our element inside the ambulance loop. A this point, you have a loop ( ambulance ) made up of a single monitor element called detect . Loop and Element uid Loop uid ambulance must be unique in the whole app, instead detect (monitor uid) must be so only within the loop to which it belongs. This allow to address an element by its path (eg. ambulance.detect ). detect () function is the monitor element. It accepts at least two positional params: stream item ( emergency ) - the value in input of an element. The elements talk with each other by streams as ReactiveX philosophy. on_next - is the function to call with the value to pass to the next linked elements ( subscribed () ). It can be called 0 or N times, you haven't to confused with the function return . Go ahead with a plan for add policies in case of an emergency detected. @loop . plan ( uid = 'custom_policy' ) # (1) def policy ( emergency , on_next , self ): # Emergency plans if emergency is True : on_next ({ 'speed' : self . emergency_speed }) # (2) on_next ({ 'siren' : True }) else : on_next ({ 'speed' : 80 }) on_next ({ 'siren' : False }) policy . emergency_speed = 180 Differently from the monitor, here we choose the element uid ( custom_policy instead of policy ). Use the object property emergency_speed set externally. In this case, policy () has a third param self . When you add it to the function signature, you can directly access to the Element object behind the scene. This time, respect previous detect () , you pass a dict to the next linked element. The last element defined and registered is the execute element, exec applies the plan on the managed system (ie. ambulance), in our case simply print an output. @loop . execute def exec ( item , on_next ): if 'speed' in item : print ( f \"Speed: { item [ 'speed' ] } Km/h\" ) if 'siren' in item : print ( f \"Siren is { 'ON' if item [ 'siren' ] else 'OFF' } \" ) The last step to complete ambulance loop is to connect ( subscribe() ) the three elements: Subscribe Pipe detect . subscribe ( policy ) policy . subscribe ( exec ) from mape import operators as ops # (1) # Alternative way detect . pipe ( ops . through ( policy ), ops . through ( exec ) ) . subscribe () ops are all the RxPY operators plus some more extras. You are finally ready to try your ambulance emergency system, sending a detected emergency to the monitor element detect : detect ( True ) # (1) Just call the detect () function and pass the item as param. As you can see, nothing happens ! This is the wanted behaviour, because you have to start element detect whenever you are ready to receive the stream. Different elements behaviour Elements can have 3 different behaviours respect to the stream passing through them: manual start ( monitor ): the element cannot send or receive items until the .start() method invocation. This is often related to internal resource lifetime (eg. DB connection, socket, ...). It allows to connect all loops and elements before start receiving the stream. start on subscribe ( analyzer, planner ): the element will be started when someone is interested to it (ie. subscribed() ). start on init ( executer ): the element is ready from its initialization. So, we start the monitor element and simulate an emergency: detect . start () detect ( True ) Get the results: Speed: 180 Siren is ON Again, ending the emergency (ie. False ): detect ( False ) Get the results: Speed: 80 Siren is OFF Operators \u00b6 Inspired by the functional programming, there are plenty operators available in RxPY and directly usable in PyMAPE. They can be chained in a pipeline, allowing transformations, combinations, filtering, grouping, error managing, applying conditions, making math operations, and so on . There are more than 140 operators (about 400 variants), and we advise and encourage the creation of your custom operators following your need. Filters \u00b6 In the ambulance example there is an issue. If the monitor collect an emergency multiple time, all the following element (planner and executer) are invoked. detect ( True ) # Speed: 180 # Siren is ON detect ( True ) # Speed: 180 # Siren is ON # ... Same on emergency end detect ( False ) # Speed: 80 # Siren is OFF detect ( False ) # Speed: 80 # Siren is OFF # ... To solve the problem, we can put a filter at the input of planner (or the output of monitor): Element Pipe @loop . plan ( uid = 'custom_policy' , ops_in = ops . distinct_until_changed ()) # (1) def policy ( emergency , on_next , self ): # Emergency plans if emergency is True : on_next ({ 'speed' : self . emergency_speed }) # (2) on_next ({ 'siren' : True }) else : on_next ({ 'speed' : 80 }) on_next ({ 'siren' : False }) Simply use the param ops_out to put the operator on output. # In alternative we can add filter in the pipe chain detect . pipe ( ops . distinct_until_changed (), ops . through ( policy ), ops . through ( exec ) ) . subscribe () distinct_until_changed () allows sequence that contains only distinct contiguous item. A better example Ambulance can be not the best example to understand the use of distinct_until_changed () , but try to image a monitor that use polling to read state of managed system. The values read can be the same until the system change the state (eg. motion detection, ambient temprature, ...). Loop and Element access \u00b6 PyMAPE provide a simplified access to his main entities. For example, you can iterate: # Iterate over all loops and elements defined in the app for loop in mape . app : print ( f \"* { loop . uid } \" ) for element in loop : print ( f \" - { element . uid } \" ) Returns: * ambulance - detect - custom_policy - exec ...or use python list comprehension to retrieve particular elements: # Get all execute elements [ element . uid for element in mape . app . ambulance if isinstance ( element , mape . Execute )] Returns: ['exec'] You can chain the loop and element uid ( dot-notation path ) to have direct access to the elements: mape . app . ambulance . detect # return monitor detect object Same result is obtained with: mape . app [ 'ambulance.detect' ] # (1) Allowing use of variable as dot-notation path. Debug \u00b6 Some tips for debug your loops, elements crossed by the streams. Element \u00b6 You can print the in and/or out items stream of an element: In Out In & Out Disable element . debug ( mape . Element . Debug . IN ) element . debug ( mape . Element . Debug . OUT ) from mape import Element element . debug ( Element . Debug . IN | Element . Debug . OUT ) element . debug () # (1) element . debug ( Element . Debug . DISABLE ) is equivalent Sample debug output detect ( True ) return: # detect(True) Speed: 180 (9373) on next: {'speed': 180} | in > [ambulance.exec] (2472) on next: {'speed': 180} | [ambulance.custom_policy] > out Siren is ON (9373) on next: {'siren': True} | in > [ambulance.exec] (2472) on next: {'siren': True} | [ambulance.custom_policy] > out (2073) on next: True | in > [ambulance.custom_policy] (2388) on next: True | strem out of detect() (2616) on next: True | [ambulance.detect] > out The history order is due the recursive call, on which ReactiveX is based. If necessary this beahviour can be \"fixed\" in the next realease. LogObserver \u00b6 You can create a fake element ( LogObserver ) and attach it to real element. The LogObserver doesn't modify the stream but simply print it. If you want print all the stream output from the montiro, you can modify the loop subscription of ambulance like this: detect.subscribe(LogObserver(\"stream out detect\")) detect.subscribe(policy) policy.subscribe(exec) Sample debug output detect ( True ) return: (5393) on next: True | stream out detect Speed: 180 Siren is ON","title":"First loop"},{"location":"first-loop/#ambulance-loop","text":"You'll implement this simple ambulance loop, composed of 3 connected elements: Monitor detect Planner custom_policy Executer exec In the next sections this graphical notation will be more clear. import mape mape . init () # (1) # Ambulance loop definition, named \"ambulance\" loop = mape . Loop ( uid = 'ambulance' ) # (2) # Monitor element of ambulance loop @loop . monitor # (3) def detect ( emergency , on_next ): # (4) on_next ( emergency ) mape . init () accept different params to setup PyMAPE, allowing configuration by a config file and/or directly in the source code. uid is an unique identification for the defined loop. If you don't pass an uid , system provide a random one for you. Decorator create and register the new element monitor to the ambulance loop . The function name detect is used as uid of our element inside the ambulance loop. A this point, you have a loop ( ambulance ) made up of a single monitor element called detect . Loop and Element uid Loop uid ambulance must be unique in the whole app, instead detect (monitor uid) must be so only within the loop to which it belongs. This allow to address an element by its path (eg. ambulance.detect ). detect () function is the monitor element. It accepts at least two positional params: stream item ( emergency ) - the value in input of an element. The elements talk with each other by streams as ReactiveX philosophy. on_next - is the function to call with the value to pass to the next linked elements ( subscribed () ). It can be called 0 or N times, you haven't to confused with the function return . Go ahead with a plan for add policies in case of an emergency detected. @loop . plan ( uid = 'custom_policy' ) # (1) def policy ( emergency , on_next , self ): # Emergency plans if emergency is True : on_next ({ 'speed' : self . emergency_speed }) # (2) on_next ({ 'siren' : True }) else : on_next ({ 'speed' : 80 }) on_next ({ 'siren' : False }) policy . emergency_speed = 180 Differently from the monitor, here we choose the element uid ( custom_policy instead of policy ). Use the object property emergency_speed set externally. In this case, policy () has a third param self . When you add it to the function signature, you can directly access to the Element object behind the scene. This time, respect previous detect () , you pass a dict to the next linked element. The last element defined and registered is the execute element, exec applies the plan on the managed system (ie. ambulance), in our case simply print an output. @loop . execute def exec ( item , on_next ): if 'speed' in item : print ( f \"Speed: { item [ 'speed' ] } Km/h\" ) if 'siren' in item : print ( f \"Siren is { 'ON' if item [ 'siren' ] else 'OFF' } \" ) The last step to complete ambulance loop is to connect ( subscribe() ) the three elements: Subscribe Pipe detect . subscribe ( policy ) policy . subscribe ( exec ) from mape import operators as ops # (1) # Alternative way detect . pipe ( ops . through ( policy ), ops . through ( exec ) ) . subscribe () ops are all the RxPY operators plus some more extras. You are finally ready to try your ambulance emergency system, sending a detected emergency to the monitor element detect : detect ( True ) # (1) Just call the detect () function and pass the item as param. As you can see, nothing happens ! This is the wanted behaviour, because you have to start element detect whenever you are ready to receive the stream. Different elements behaviour Elements can have 3 different behaviours respect to the stream passing through them: manual start ( monitor ): the element cannot send or receive items until the .start() method invocation. This is often related to internal resource lifetime (eg. DB connection, socket, ...). It allows to connect all loops and elements before start receiving the stream. start on subscribe ( analyzer, planner ): the element will be started when someone is interested to it (ie. subscribed() ). start on init ( executer ): the element is ready from its initialization. So, we start the monitor element and simulate an emergency: detect . start () detect ( True ) Get the results: Speed: 180 Siren is ON Again, ending the emergency (ie. False ): detect ( False ) Get the results: Speed: 80 Siren is OFF","title":"Ambulance loop"},{"location":"first-loop/#operators","text":"Inspired by the functional programming, there are plenty operators available in RxPY and directly usable in PyMAPE. They can be chained in a pipeline, allowing transformations, combinations, filtering, grouping, error managing, applying conditions, making math operations, and so on . There are more than 140 operators (about 400 variants), and we advise and encourage the creation of your custom operators following your need.","title":"Operators"},{"location":"first-loop/#filters","text":"In the ambulance example there is an issue. If the monitor collect an emergency multiple time, all the following element (planner and executer) are invoked. detect ( True ) # Speed: 180 # Siren is ON detect ( True ) # Speed: 180 # Siren is ON # ... Same on emergency end detect ( False ) # Speed: 80 # Siren is OFF detect ( False ) # Speed: 80 # Siren is OFF # ... To solve the problem, we can put a filter at the input of planner (or the output of monitor): Element Pipe @loop . plan ( uid = 'custom_policy' , ops_in = ops . distinct_until_changed ()) # (1) def policy ( emergency , on_next , self ): # Emergency plans if emergency is True : on_next ({ 'speed' : self . emergency_speed }) # (2) on_next ({ 'siren' : True }) else : on_next ({ 'speed' : 80 }) on_next ({ 'siren' : False }) Simply use the param ops_out to put the operator on output. # In alternative we can add filter in the pipe chain detect . pipe ( ops . distinct_until_changed (), ops . through ( policy ), ops . through ( exec ) ) . subscribe () distinct_until_changed () allows sequence that contains only distinct contiguous item. A better example Ambulance can be not the best example to understand the use of distinct_until_changed () , but try to image a monitor that use polling to read state of managed system. The values read can be the same until the system change the state (eg. motion detection, ambient temprature, ...).","title":"Filters"},{"location":"first-loop/#loop-and-element-access","text":"PyMAPE provide a simplified access to his main entities. For example, you can iterate: # Iterate over all loops and elements defined in the app for loop in mape . app : print ( f \"* { loop . uid } \" ) for element in loop : print ( f \" - { element . uid } \" ) Returns: * ambulance - detect - custom_policy - exec ...or use python list comprehension to retrieve particular elements: # Get all execute elements [ element . uid for element in mape . app . ambulance if isinstance ( element , mape . Execute )] Returns: ['exec'] You can chain the loop and element uid ( dot-notation path ) to have direct access to the elements: mape . app . ambulance . detect # return monitor detect object Same result is obtained with: mape . app [ 'ambulance.detect' ] # (1) Allowing use of variable as dot-notation path.","title":"Loop and Element access"},{"location":"first-loop/#debug","text":"Some tips for debug your loops, elements crossed by the streams.","title":"Debug"},{"location":"first-loop/#element","text":"You can print the in and/or out items stream of an element: In Out In & Out Disable element . debug ( mape . Element . Debug . IN ) element . debug ( mape . Element . Debug . OUT ) from mape import Element element . debug ( Element . Debug . IN | Element . Debug . OUT ) element . debug () # (1) element . debug ( Element . Debug . DISABLE ) is equivalent Sample debug output detect ( True ) return: # detect(True) Speed: 180 (9373) on next: {'speed': 180} | in > [ambulance.exec] (2472) on next: {'speed': 180} | [ambulance.custom_policy] > out Siren is ON (9373) on next: {'siren': True} | in > [ambulance.exec] (2472) on next: {'siren': True} | [ambulance.custom_policy] > out (2073) on next: True | in > [ambulance.custom_policy] (2388) on next: True | strem out of detect() (2616) on next: True | [ambulance.detect] > out The history order is due the recursive call, on which ReactiveX is based. If necessary this beahviour can be \"fixed\" in the next realease.","title":"Element"},{"location":"first-loop/#logobserver","text":"You can create a fake element ( LogObserver ) and attach it to real element. The LogObserver doesn't modify the stream but simply print it. If you want print all the stream output from the montiro, you can modify the loop subscription of ambulance like this: detect.subscribe(LogObserver(\"stream out detect\")) detect.subscribe(policy) policy.subscribe(exec) Sample debug output detect ( True ) return: (5393) on next: True | stream out detect Speed: 180 Siren is ON","title":"LogObserver"},{"location":"installation/","text":"PyMAPE can be simply installed using pip, directly in your system or in a separated virtual environment to keep clean your main system. System Virtualenv $ pip install pymape ---> 100% $ python -m venv venv $ source venv/bin/activate # ( venv ) $ pip install pymape ---> 100% Examples dependencies If you intend play with the provided examples of different MAPE-K patterns, you should also install the dependency pip install -r examples/requirements.txt . Anyway before play with them, we need to run some docker containers. We will see them soon. Installation for Developers and Contributors \u00b6 If you want to contribute to the project, you have use poetry and follow the steps below: $ git clone https://github.com/elbowz/PyMAPE.git $ cd PyMAPE $ poetry install ---> 100% Then use poetry shell and/or poetry run (eg. poetry run examples/coordinated-ambulance.py --speed 80 ) to exec a script inside the development environment. Poetry and examples dependencies Using poetry you won't have to install the python packages dependencies needed to execute the examples .","title":"Installation"},{"location":"installation/#installation-for-developers-and-contributors","text":"If you want to contribute to the project, you have use poetry and follow the steps below: $ git clone https://github.com/elbowz/PyMAPE.git $ cd PyMAPE $ poetry install ---> 100% Then use poetry shell and/or poetry run (eg. poetry run examples/coordinated-ambulance.py --speed 80 ) to exec a script inside the development environment. Poetry and examples dependencies Using poetry you won't have to install the python packages dependencies needed to execute the examples .","title":"Installation for Developers and Contributors"},{"location":"typography/","text":"Decentralized Monitor Analyze Plan Execute Knowledge loops Software framework to support the development and deployment of Autonomous (Self-Adaptive) Systems Getting Started \u00b6 Install \u00b6 pip install pymape See Examples for play with some MAPE-K patterns. Install for Developers and Contributors \u00b6 git clone https://github.com/elbowz/PyMAPE.git cd PyMAPE poetry install note: you need to have already installed poetry Then use poetry shell and/or poetry run (eg. poetry run examples/coordinated-ambulance.py --speed 80 ) to exec your script inside the development environment. First loop (Ambulance) \u00b6 import mape from mape.loop import Loop \"\"\" MAPE Loop and elements definition \"\"\" loop = Loop ( uid = 'ambulance_emergency' ) @loop . monitor def detect ( item , on_next , self ): if 'speed_limit' in item : # Local volatile knowledge self . loop . k . speed_limit = item [ 'speed_limit' ] elif 'emergency_detect' in item : on_next ( item [ 'emergency_detect' ]) @loop . plan ( ops_in = ops . distinct_until_changed ()) async def policy ( emergency , on_next , self ): if emergency is True : self . last_speed_limit = self . loop . k . speed_limit new_speed = max ( self . last_speed_limit , self . emergency_speed ) on_next ({ 'speed' : new_speed }) on_next ({ 'siren' : True }) else : on_next ({ 'speed' : self . last_speed_limit }) on_next ({ 'siren' : False }) policy . emergency_speed = 160 @loop . execute def exec ( item : dict , on_next ): if 'speed' in item : ambulance . speed_limit = item [ 'speed' ] if 'siren' in item : ambulance . siren = item [ 'siren' ] for element in loop : element . debug ( Element . Debug . IN ) \"\"\" MAPE Elements connection \"\"\" detect . subscribe ( policy ) policy . subscribe ( exec ) # (1) # Starting monitor... detect . start () I'm a code annotation! I can contain code , formatted text , images, ... basically anything that can be written in Markdown. The range () function is used to generate a sequence of numbers. The HTML specification is maintained by the W3C . Hover me Traversing \u00b6 # Iterate over loops and element for loop in mape . app : logger . debug ( f \"* { loop . uid } \" ) for element in loop : logger . debug ( f \" - { element . uid } \" ) # Get all Execute elements [ element for element in loop_obj if isinstance ( element , Execute )] # Different access way to loop/element through dot-notation (path) mape . app . loop_uid . element_uid mape . app [ 'loop_uid.element_uid' ] 8.0.0 \u00b7 Feature flag Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. (1) Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa (2). I'm an annotation! I'm an annotation as well! If you already know what is a Self-Adaptive system and a MAPE-K loop: Getting Started Tab 1 Tab 2 # Iterate over loops and element for loop in mape . app : logger . debug ( f \"* { loop . uid } \" ) for element in loop : logger . debug ( f \" - { element . uid } \" ) # Get all Execute elements [ element for element in loop_obj if isinstance ( element , Execute )] # Different access way to loop/element through dot-notation (path) mape . app . loop_uid . element_uid mape . app [ 'loop_uid.element_uid' ] Phasellus posuere in sem ut cursus (1) casazzo \u00b6 $ pip install pymape ---> 100% Come fa # >>> $ ecco un custom prompt // sadasd $ a me si dai sdsd Docs \u00b6 Slides \u00b6 Introduction to PyMAPE with examples Examples \u00b6 Implementation of the 5 decentralized (and distributed) MAPE patterns described in the paper: \"On Patterns for Decentralized Control in Self-Adaptive Systems\", Danny Weyns Ambulance-Car Emergency (Information Sharing and Coordinated Control) Average Speed Enforcement (Master/Slave) Dynamic Carriageway (Regional Planning) Cruise Control with Distance Hold (Hierarchical Control) If you want try some examples (path examples/ ), refer to section # CLI EXAMPLES inside the source code of each one. The examples need furthers requirements, please see pyproject.toml or use poetry to install them . You also need a Redis and InfluxDB instance running, for example: docker run --name mape-redis -p 6379 :6379 \\ -v $( pwd ) /docker/redis:/usr/local/etc/redis \\ --rm redis redis-server /usr/local/etc/redis/redis.conf docker run --name mape-influxdb -p 8086 :8086 \\ -v $( pwd ) /docker/influxdb/data:/var/lib/influxdb2 \\ -v $( pwd ) /docker/influxdb/conf:/etc/influxdb2 \\ -e DOCKER_INFLUXDB_INIT_MODE = setup \\ -e DOCKER_INFLUXDB_INIT_USERNAME = user \\ -e DOCKER_INFLUXDB_INIT_PASSWORD = qwerty123456 \\ -e DOCKER_INFLUXDB_INIT_ORG = univaq \\ -e DOCKER_INFLUXDB_INIT_BUCKET = mape \\ -e DOCKER_INFLUXDB_INIT_RETENTION = 1w \\ -e DOCKER_INFLUXDB_INIT_ADMIN_TOKEN = <GENERATE_OR_TAKE_FROM_CONFIG_YAML> \\ --rm influxdb:2.0 See source for more information.","title":"Typography"},{"location":"typography/#getting-started","text":"","title":"Getting Started"},{"location":"typography/#install","text":"pip install pymape See Examples for play with some MAPE-K patterns.","title":"Install"},{"location":"typography/#install-for-developers-and-contributors","text":"git clone https://github.com/elbowz/PyMAPE.git cd PyMAPE poetry install note: you need to have already installed poetry Then use poetry shell and/or poetry run (eg. poetry run examples/coordinated-ambulance.py --speed 80 ) to exec your script inside the development environment.","title":"Install for Developers and Contributors"},{"location":"typography/#first-loop-ambulance","text":"import mape from mape.loop import Loop \"\"\" MAPE Loop and elements definition \"\"\" loop = Loop ( uid = 'ambulance_emergency' ) @loop . monitor def detect ( item , on_next , self ): if 'speed_limit' in item : # Local volatile knowledge self . loop . k . speed_limit = item [ 'speed_limit' ] elif 'emergency_detect' in item : on_next ( item [ 'emergency_detect' ]) @loop . plan ( ops_in = ops . distinct_until_changed ()) async def policy ( emergency , on_next , self ): if emergency is True : self . last_speed_limit = self . loop . k . speed_limit new_speed = max ( self . last_speed_limit , self . emergency_speed ) on_next ({ 'speed' : new_speed }) on_next ({ 'siren' : True }) else : on_next ({ 'speed' : self . last_speed_limit }) on_next ({ 'siren' : False }) policy . emergency_speed = 160 @loop . execute def exec ( item : dict , on_next ): if 'speed' in item : ambulance . speed_limit = item [ 'speed' ] if 'siren' in item : ambulance . siren = item [ 'siren' ] for element in loop : element . debug ( Element . Debug . IN ) \"\"\" MAPE Elements connection \"\"\" detect . subscribe ( policy ) policy . subscribe ( exec ) # (1) # Starting monitor... detect . start () I'm a code annotation! I can contain code , formatted text , images, ... basically anything that can be written in Markdown. The range () function is used to generate a sequence of numbers. The HTML specification is maintained by the W3C . Hover me","title":"First loop (Ambulance)"},{"location":"typography/#traversing","text":"# Iterate over loops and element for loop in mape . app : logger . debug ( f \"* { loop . uid } \" ) for element in loop : logger . debug ( f \" - { element . uid } \" ) # Get all Execute elements [ element for element in loop_obj if isinstance ( element , Execute )] # Different access way to loop/element through dot-notation (path) mape . app . loop_uid . element_uid mape . app [ 'loop_uid.element_uid' ] 8.0.0 \u00b7 Feature flag Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. (1) Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa (2). I'm an annotation! I'm an annotation as well! If you already know what is a Self-Adaptive system and a MAPE-K loop: Getting Started Tab 1 Tab 2 # Iterate over loops and element for loop in mape . app : logger . debug ( f \"* { loop . uid } \" ) for element in loop : logger . debug ( f \" - { element . uid } \" ) # Get all Execute elements [ element for element in loop_obj if isinstance ( element , Execute )] # Different access way to loop/element through dot-notation (path) mape . app . loop_uid . element_uid mape . app [ 'loop_uid.element_uid' ] Phasellus posuere in sem ut cursus (1)","title":"Traversing"},{"location":"typography/#casazzo","text":"$ pip install pymape ---> 100% Come fa # >>> $ ecco un custom prompt // sadasd $ a me si dai sdsd","title":"casazzo"},{"location":"typography/#docs","text":"","title":"Docs"},{"location":"typography/#slides","text":"Introduction to PyMAPE with examples","title":"Slides"},{"location":"typography/#examples","text":"Implementation of the 5 decentralized (and distributed) MAPE patterns described in the paper: \"On Patterns for Decentralized Control in Self-Adaptive Systems\", Danny Weyns Ambulance-Car Emergency (Information Sharing and Coordinated Control) Average Speed Enforcement (Master/Slave) Dynamic Carriageway (Regional Planning) Cruise Control with Distance Hold (Hierarchical Control) If you want try some examples (path examples/ ), refer to section # CLI EXAMPLES inside the source code of each one. The examples need furthers requirements, please see pyproject.toml or use poetry to install them . You also need a Redis and InfluxDB instance running, for example: docker run --name mape-redis -p 6379 :6379 \\ -v $( pwd ) /docker/redis:/usr/local/etc/redis \\ --rm redis redis-server /usr/local/etc/redis/redis.conf docker run --name mape-influxdb -p 8086 :8086 \\ -v $( pwd ) /docker/influxdb/data:/var/lib/influxdb2 \\ -v $( pwd ) /docker/influxdb/conf:/etc/influxdb2 \\ -e DOCKER_INFLUXDB_INIT_MODE = setup \\ -e DOCKER_INFLUXDB_INIT_USERNAME = user \\ -e DOCKER_INFLUXDB_INIT_PASSWORD = qwerty123456 \\ -e DOCKER_INFLUXDB_INIT_ORG = univaq \\ -e DOCKER_INFLUXDB_INIT_BUCKET = mape \\ -e DOCKER_INFLUXDB_INIT_RETENTION = 1w \\ -e DOCKER_INFLUXDB_INIT_ADMIN_TOKEN = <GENERATE_OR_TAKE_FROM_CONFIG_YAML> \\ --rm influxdb:2.0 See source for more information.","title":"Examples"},{"location":"reference/element/","text":"L' Element is the central part of the framework. It will have to communicate with others elements in the seme loop or with externals ones. Usually you'll have a Monitor , followed by an Analyzer , then a Planner and finally the Executer , but this order is not mandatory, and you can have different combination of them. Internal view \u00b6 Let's look inside an Element and try to understand how it works: Start behaviors \u00b6 In the top-left corner you can see three icons characterizing the respective behaviour: manual start ( monitor ): the element cannot send or receive items until the .start() method invocation. This is often related to internal resource lifetime (eg. DB connection, socket, ...). It allows to connect all loops and elements before start receiving the stream. start on subscribe ( analyzer, planner ): the element will be started when someone is interested to it (ie. subscribed() ). start on init ( executer ): the element is ready from its initialization. Start / Stop See in the above figure, the dotted line with at the end a scissor, to better understand the start/stop meaning. Each element can be started ( element . start () ) and stopped ( element . stop () ), and check the current state by ( element . is_running ). The different behaviours are defined in the classes StartOnSubscrie , StartOnInit allowing extension and change as preferred. Ports \u00b6 On the front and back of the element, there are the ports ( IN and OUT ). They allow both writing and reading of the stream. You can configure different architect flows, not only serial communication but also parallelization, multiplexing, fork, and merge of the stream. Stopped (isolated) element If an element is stopped, the ports are disconnected, and it is isolated, but still allowing the communication of others elements eventually connected to that ports (again see the image above to figure out). Pipes \u00b6 Here you can add the ReactiveX operators , applying in input and/or output: filtering - eg. filter() , distinct() pre and post processing - eg. throttle() , debounce() minimizing the data exchange - eg. sample() internal PyMAPE operators - eg. router() , group_and_pipe() your custom ones , etc... Function and CallMethod \u00b6 The element can compute a \"normal\" stream, where each item in input can generate 0 or more items in output (with the use of on_next(item) function). No input Rememeber that you are in the field of reactive programming and push messages. The element can generate a stream (items) without any input, or the contrary (eg. monitor element produce items without any input). If you send a CallMethod object (as item), thanks to its payload you can call an element method with respective params. Message driven CallMethod approach is based on the message driven paradigm (part of reactive programming), where you increase the element decoupling between elements and formalize the use of a common interface. Of course, you can still call the element class method. Element notation \u00b6 The framework trys also to introduce a graphical notation. In the figure below, you can see the final and imploded representation of an element. Start behaviour , ports , pipe operators , uid , and class element are still visible.","title":"Element"},{"location":"reference/element/#internal-view","text":"Let's look inside an Element and try to understand how it works:","title":"Internal view"},{"location":"reference/element/#start-behaviors","text":"In the top-left corner you can see three icons characterizing the respective behaviour: manual start ( monitor ): the element cannot send or receive items until the .start() method invocation. This is often related to internal resource lifetime (eg. DB connection, socket, ...). It allows to connect all loops and elements before start receiving the stream. start on subscribe ( analyzer, planner ): the element will be started when someone is interested to it (ie. subscribed() ). start on init ( executer ): the element is ready from its initialization. Start / Stop See in the above figure, the dotted line with at the end a scissor, to better understand the start/stop meaning. Each element can be started ( element . start () ) and stopped ( element . stop () ), and check the current state by ( element . is_running ). The different behaviours are defined in the classes StartOnSubscrie , StartOnInit allowing extension and change as preferred.","title":"Start behaviors"},{"location":"reference/element/#ports","text":"On the front and back of the element, there are the ports ( IN and OUT ). They allow both writing and reading of the stream. You can configure different architect flows, not only serial communication but also parallelization, multiplexing, fork, and merge of the stream. Stopped (isolated) element If an element is stopped, the ports are disconnected, and it is isolated, but still allowing the communication of others elements eventually connected to that ports (again see the image above to figure out).","title":"Ports"},{"location":"reference/element/#pipes","text":"Here you can add the ReactiveX operators , applying in input and/or output: filtering - eg. filter() , distinct() pre and post processing - eg. throttle() , debounce() minimizing the data exchange - eg. sample() internal PyMAPE operators - eg. router() , group_and_pipe() your custom ones , etc...","title":"Pipes"},{"location":"reference/element/#function-and-callmethod","text":"The element can compute a \"normal\" stream, where each item in input can generate 0 or more items in output (with the use of on_next(item) function). No input Rememeber that you are in the field of reactive programming and push messages. The element can generate a stream (items) without any input, or the contrary (eg. monitor element produce items without any input). If you send a CallMethod object (as item), thanks to its payload you can call an element method with respective params. Message driven CallMethod approach is based on the message driven paradigm (part of reactive programming), where you increase the element decoupling between elements and formalize the use of a common interface. Of course, you can still call the element class method.","title":"Function and CallMethod"},{"location":"reference/element/#element-notation","text":"The framework trys also to introduce a graphical notation. In the figure below, you can see the final and imploded representation of an element. Start behaviour , ports , pipe operators , uid , and class element are still visible.","title":"Element notation"},{"location":"reference/entities/","text":"To know the entities that compose PyMAPE, and their relationships, you can see a shrink version of its metamodel. Metamodel \u00b6 Entities \u00b6 Explore the entities (used to develop your loops), starting from left to right: mape package allows the configuration by init () method and also by a config file (default: mape.yml in your working directory) or a mix of both. init () has priority over the file. From mape you have direct access to app and config . config dict exposes all your configuration (eg. mape . config [ 'debug' ] ), and you can also use it for your purpose, putting what you want in the configuration file. App gives access to all declared MAPE loops, levels, and the global Knowledge Loop is identified by a uid, contains its Element, has its Knowledge, and give access to the main app object (ie. loop.app ) and its level (if exists). Level is optional (there is an empty one by default), It can be used to describe a hierarchical control pattern. At each level with its uid can be associated more loops. Element (ie. M, A, P, E) is the pillar of PyMAPE framework, the center of the metamodel. They have an uid, but must be unique only inside its loop. There are different kinds of elements ( Monitor, Analyze, Plan, Execute ) and relative behaviors ( base, StartOnSubscribe, StartOnInit ). It has two ports (in and out), that allow to put within a stream. The operators can be added in the ports itself, or between elements (in the operators pipe). There are three different Knowledge , with different scopes (App, Level, and Loop). You can access each of them from its object (eg. loop . k ). You can use it like a local storage object, or as centralized memory shared by the app deployed on a different machine (using redis). operators are the ones defined in the ReactiveX standard enriched with some specific and useful to our purpose. The classes Message and CallMethod can be used as items of the stream, enriched with additional information in the payload. This allows addressing our stream give at each item a destination or applying some kind of routing algorithm ( Message ), like the IP packets. The CallMethod item allows calling the remote methods (of elements) using the stream. you have already seen the loop_decorator in the First loop section, used to register elements to a loop. element_decorator provides a set of decorators to define the Element class starting from a simple function. These decorators (as the above) are syntactic sugar to speed up development. Info Please refer to the First loop section and the following sections, to see how and when these entities are used. mape \u00b6 init ( debug , asyncio_loop , redis_url , rest_host_port , config_file ) debug = False Enable more verbose mode. asyncio_loop = None Provide your asyncio loop or leave PyMAPE to generate one for you. redis_url = None Url of your Redis instance (eg. redis://localhost:6379 ) rest_host_port = None Web server host:port , where some REST API endpoint will be provided (eg. 0.0.0.0:6060 ). config_file = mape.yml Path (absolute or relative to working directory) to the config file.","title":"Main entities"},{"location":"reference/entities/#metamodel","text":"","title":"Metamodel"},{"location":"reference/entities/#entities","text":"Explore the entities (used to develop your loops), starting from left to right: mape package allows the configuration by init () method and also by a config file (default: mape.yml in your working directory) or a mix of both. init () has priority over the file. From mape you have direct access to app and config . config dict exposes all your configuration (eg. mape . config [ 'debug' ] ), and you can also use it for your purpose, putting what you want in the configuration file. App gives access to all declared MAPE loops, levels, and the global Knowledge Loop is identified by a uid, contains its Element, has its Knowledge, and give access to the main app object (ie. loop.app ) and its level (if exists). Level is optional (there is an empty one by default), It can be used to describe a hierarchical control pattern. At each level with its uid can be associated more loops. Element (ie. M, A, P, E) is the pillar of PyMAPE framework, the center of the metamodel. They have an uid, but must be unique only inside its loop. There are different kinds of elements ( Monitor, Analyze, Plan, Execute ) and relative behaviors ( base, StartOnSubscribe, StartOnInit ). It has two ports (in and out), that allow to put within a stream. The operators can be added in the ports itself, or between elements (in the operators pipe). There are three different Knowledge , with different scopes (App, Level, and Loop). You can access each of them from its object (eg. loop . k ). You can use it like a local storage object, or as centralized memory shared by the app deployed on a different machine (using redis). operators are the ones defined in the ReactiveX standard enriched with some specific and useful to our purpose. The classes Message and CallMethod can be used as items of the stream, enriched with additional information in the payload. This allows addressing our stream give at each item a destination or applying some kind of routing algorithm ( Message ), like the IP packets. The CallMethod item allows calling the remote methods (of elements) using the stream. you have already seen the loop_decorator in the First loop section, used to register elements to a loop. element_decorator provides a set of decorators to define the Element class starting from a simple function. These decorators (as the above) are syntactic sugar to speed up development. Info Please refer to the First loop section and the following sections, to see how and when these entities are used.","title":"Entities"},{"location":"reference/entities/#mape","text":"init ( debug , asyncio_loop , redis_url , rest_host_port , config_file ) debug = False Enable more verbose mode. asyncio_loop = None Provide your asyncio loop or leave PyMAPE to generate one for you. redis_url = None Url of your Redis instance (eg. redis://localhost:6379 ) rest_host_port = None Web server host:port , where some REST API endpoint will be provided (eg. 0.0.0.0:6060 ). config_file = mape.yml Path (absolute or relative to working directory) to the config file.","title":"mape"},{"location":"reference/graphical-notation/","text":"","title":"Graphical notation"},{"location":"reference/remote/","text":"One important point of PyMAPE is the capability of decentralize (functionalities and data) and distribute loops on more devices. These features are reached by the remote package. Class diagram \u00b6 PyMAPE tries to preserve the best flexibility to the user design choices. You know pros and cons of different communication architect based on request-response (eg. polling) respect to publish-subscribe (eg. data centralization). So there are some domains (and patterns) that prefer one approach over the other, or again hybrid one to exploit the advantage of each one. You can choose between: RESTful implementation, allowing reading and writing access to the elements of your application Redis as DB and message broker, allowing the communication between elements and also as shared memory ( Knowledge ) for distribute nodes. Observable and Observer In the class diagram there are some class with the post-fix \"Observer\" and \"Observable\" , key concepts in the ReactiveX library. Also the element ports use the same idea. You can think them as sink and source for your stream. Graphical Notation \u00b6 REST \u00b6 For enable the REST support you have to provide an host:port for the web server ( Uvicorn used by FastAPI ). For do that you can: init() mape.yml mape . init ( rest_host_port = \"0.0.0.0:6060\" ) rest : host_port : 0.0.0.0:6060 Now you can get information about levels, loops, ad elements defined in your app, but mainly you can push items to any element port through a POST request ( POSTObserver class). API documentation API documentation and a web ui for test is available: OpenAPI: /openapi.json Swagger: /docs ReDoc: /redoc Thanks to the FastAPI library. POSTObserver ( base_url , path , port , serializer , session ) It behaves like a sink, sending the stream to the host:port device selected and element selected by the path. base_url: str In the format host:port of the REST API web server target. path: str Element path ( loop_uid.element_uid ) target port: Port = Port.p_in Destination port where inject the stream serializer = None session: aiohttp.ClientSession = None Example \u00b6 In the following example you see a communication between two distributed devices ( Car_panda and Ambulance ), specifically between the port out of detect element of car_panda ( car_panda.detect ) and port in of policy element of ambulance ( ambulance.policy ). Translated in python on device Car_panda from mape.remote.rest import POSTObserver car = mape . Loop ( uid = 'car_panda' ) @car . monitor def detect ( item , on_next ): ... # Create the sink ambulance_policy = POSTObserver ( \"http://0.0.0.0:6060\" , \"ambulance.policy\" ) # Connect detect to the sink detect . subscribe ( ambulance_policy ) and device Ambulance # Enable REST support mape . init ( rest_host_port = \"0.0.0.0:6060\" ) ambulance = mape . Loop ( uid = 'ambulance' ) ... @ambulance . plan ( ops_in = ops . distinct_until_changed ()) def policy ( item , on_next ): ... Redis \u00b6 For enable the Redis support you have to provide an url for your instance redis://localhost:6379 . For do that you can: init() mape.yml mape . init ( redis_url = \"redis://localhost:6379\" ) redis : url : redis://localhost:6379 Redis instance PyMAPE doesn't provide (yet) an instance of Redis so you have to run your own, for example using a docker container: $ docker run --name mape-redis -p 6379 :6379 -v $( pwd ) /docker/redis:/usr/local/etc/redis --rm redis redis-server /usr/local/etc/redis/redis.conf oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=1, just started Configuration loaded * monotonic clock: POSIX clock_gettime * Running mode=standalone, port=6379. Server initialized Redis unlike REST have two class to allow stream communication (on distributed devices): PubObserve e SubObservable . This mean that you have to choose a channel name, and publish/subscribe a stream on it. Pattern matching Redis supports channel pattern matching, allowing multi-points communication. car_?.detect : can receive from car_a.detect , car_b.detect , etc... car_[xy].detect : can receive only from car_x.detect , car_y.detect car_* : can receive from car_foo , car_bar , etc... Example \u00b6 Let's implement the previous example with Redis. Translated in python on device Car_panda from mape.remote.redis import PubObserver # Enable Redis support mape . init ( redis_url = \"redis://localhost:6379\" ) car = mape . Loop ( uid = 'car_panda' ) @car . monitor def detect ( item , on_next ): ... # Publish detect output on channel named \"car_panda.detect\" detect . subscribe ( PubObserver ( detect . path )) and device Ambulance from mape.remote.redis import SubObservable # Enable Redis support mape . init ( redis_url = \"redis://localhost:6379\" ) ambulance = mape . Loop ( uid = 'ambulance' ) ... @ambulance . plan ( ops_in = ops . distinct_until_changed ()) def policy ( item , on_next ): ... # Subscribe to others cars # note: for clarity can be used \"policy.port_in\" SubObservable ( \"car_*.detect\" ) . subscribe ( policy ) # (1) if you have access to car detect element you can use f \"car_*. { detect } \" == f \"car_*. { detect . uid } \"","title":"Remote package"},{"location":"reference/remote/#class-diagram","text":"PyMAPE tries to preserve the best flexibility to the user design choices. You know pros and cons of different communication architect based on request-response (eg. polling) respect to publish-subscribe (eg. data centralization). So there are some domains (and patterns) that prefer one approach over the other, or again hybrid one to exploit the advantage of each one. You can choose between: RESTful implementation, allowing reading and writing access to the elements of your application Redis as DB and message broker, allowing the communication between elements and also as shared memory ( Knowledge ) for distribute nodes. Observable and Observer In the class diagram there are some class with the post-fix \"Observer\" and \"Observable\" , key concepts in the ReactiveX library. Also the element ports use the same idea. You can think them as sink and source for your stream.","title":"Class diagram"},{"location":"reference/remote/#graphical-notation","text":"","title":"Graphical Notation"},{"location":"reference/remote/#rest","text":"For enable the REST support you have to provide an host:port for the web server ( Uvicorn used by FastAPI ). For do that you can: init() mape.yml mape . init ( rest_host_port = \"0.0.0.0:6060\" ) rest : host_port : 0.0.0.0:6060 Now you can get information about levels, loops, ad elements defined in your app, but mainly you can push items to any element port through a POST request ( POSTObserver class). API documentation API documentation and a web ui for test is available: OpenAPI: /openapi.json Swagger: /docs ReDoc: /redoc Thanks to the FastAPI library. POSTObserver ( base_url , path , port , serializer , session ) It behaves like a sink, sending the stream to the host:port device selected and element selected by the path. base_url: str In the format host:port of the REST API web server target. path: str Element path ( loop_uid.element_uid ) target port: Port = Port.p_in Destination port where inject the stream serializer = None session: aiohttp.ClientSession = None","title":"REST"},{"location":"reference/remote/#example","text":"In the following example you see a communication between two distributed devices ( Car_panda and Ambulance ), specifically between the port out of detect element of car_panda ( car_panda.detect ) and port in of policy element of ambulance ( ambulance.policy ). Translated in python on device Car_panda from mape.remote.rest import POSTObserver car = mape . Loop ( uid = 'car_panda' ) @car . monitor def detect ( item , on_next ): ... # Create the sink ambulance_policy = POSTObserver ( \"http://0.0.0.0:6060\" , \"ambulance.policy\" ) # Connect detect to the sink detect . subscribe ( ambulance_policy ) and device Ambulance # Enable REST support mape . init ( rest_host_port = \"0.0.0.0:6060\" ) ambulance = mape . Loop ( uid = 'ambulance' ) ... @ambulance . plan ( ops_in = ops . distinct_until_changed ()) def policy ( item , on_next ): ...","title":"Example"},{"location":"reference/remote/#redis","text":"For enable the Redis support you have to provide an url for your instance redis://localhost:6379 . For do that you can: init() mape.yml mape . init ( redis_url = \"redis://localhost:6379\" ) redis : url : redis://localhost:6379 Redis instance PyMAPE doesn't provide (yet) an instance of Redis so you have to run your own, for example using a docker container: $ docker run --name mape-redis -p 6379 :6379 -v $( pwd ) /docker/redis:/usr/local/etc/redis --rm redis redis-server /usr/local/etc/redis/redis.conf oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=1, just started Configuration loaded * monotonic clock: POSIX clock_gettime * Running mode=standalone, port=6379. Server initialized Redis unlike REST have two class to allow stream communication (on distributed devices): PubObserve e SubObservable . This mean that you have to choose a channel name, and publish/subscribe a stream on it. Pattern matching Redis supports channel pattern matching, allowing multi-points communication. car_?.detect : can receive from car_a.detect , car_b.detect , etc... car_[xy].detect : can receive only from car_x.detect , car_y.detect car_* : can receive from car_foo , car_bar , etc...","title":"Redis"},{"location":"reference/remote/#example_1","text":"Let's implement the previous example with Redis. Translated in python on device Car_panda from mape.remote.redis import PubObserver # Enable Redis support mape . init ( redis_url = \"redis://localhost:6379\" ) car = mape . Loop ( uid = 'car_panda' ) @car . monitor def detect ( item , on_next ): ... # Publish detect output on channel named \"car_panda.detect\" detect . subscribe ( PubObserver ( detect . path )) and device Ambulance from mape.remote.redis import SubObservable # Enable Redis support mape . init ( redis_url = \"redis://localhost:6379\" ) ambulance = mape . Loop ( uid = 'ambulance' ) ... @ambulance . plan ( ops_in = ops . distinct_until_changed ()) def policy ( item , on_next ): ... # Subscribe to others cars # note: for clarity can be used \"policy.port_in\" SubObservable ( \"car_*.detect\" ) . subscribe ( policy ) # (1) if you have access to car detect element you can use f \"car_*. { detect } \" == f \"car_*. { detect . uid } \"","title":"Example"}]}